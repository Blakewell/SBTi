:mod:`SBTi.temperature_score`
=============================

.. py:module:: SBTi.temperature_score


Module Contents
---------------


.. py:class:: ScenarioType

   Bases: :class:`enum.Enum`

   A scenario defines which scenario should be run.

   .. attribute:: TARGETS
      :annotation: = 1

      

   .. attribute:: APPROVED_TARGETS
      :annotation: = 2

      

   .. attribute:: HIGHEST_CONTRIBUTORS
      :annotation: = 3

      

   .. attribute:: HIGHEST_CONTRIBUTORS_APPROVED
      :annotation: = 4

      

   .. method:: from_int(value)
      :staticmethod:




.. py:class:: EngagementType

   Bases: :class:`enum.Enum`

   An engagement type defines how the companies will be engaged.

   .. attribute:: SET_TARGETS
      :annotation: = 1

      

   .. attribute:: SET_SBTI_TARGETS
      :annotation: = 2

      

   .. method:: from_int(value)
      :staticmethod:


      Convert an integer to an engagement type.

      :param value: The value to convert
      :return:


   .. method:: from_string(value: str)
      :staticmethod:


      Convert a string to an engagement type.

      :param value: The value to convert
      :return:



.. py:class:: Scenario

   A scenario defines the action the portfolio holder will take to improve its temperature score.

   .. attribute:: scenario_type
      :annotation: :ScenarioType

      

   .. attribute:: engagement_type
      :annotation: :EngagementType

      

   .. attribute:: aggregation_method
      :annotation: :PortfolioAggregationMethod

      

   .. attribute:: grouping
      :annotation: :Optional[list]

      

   .. method:: from_dict(scenario_values: dict)
      :staticmethod:


      Convert a dictionary to a scenario. The dictionary should have the following keys:

      * number: The scenario type as an integer
      * engagement_type: The engagement type as a string
      * aggregation_method: The aggregation method as a string
      * grouping: The grouping columns as a list of strings

      :param scenario_values: The dictionary to convert
      :return: A scenario object matching the input values



.. py:class:: TemperatureScore(fallback_score: float = 3.2, model: int = 4, config: Type[TemperatureScoreConfig] = TemperatureScoreConfig)

   Bases: :class:`SBTi.portfolio_aggregation.PortfolioAggregation`

   This class is provides a temperature score based on the climate goals.

   :param fallback_score: The temp score if a company is not found
   :param model: The regression model to use
   :param config: A class defining the constants that are used throughout this class. This parameter is only required
                   if you'd like to overwrite a constant. This can be done by extending the TemperatureScoreConfig
                   class and overwriting one of the parameters.

   .. method:: get_target_mapping(self, target: pd.Series)


      Map the target onto an SR15 target (None if not available).

      :param target: The target as a row of a dataframe
      :return: The mapped SR15 target


   .. method:: get_annual_reduction_rate(self, target: pd.Series)


      Get the annual reduction rate (or None if not available).

      :param target: The target as a row of a dataframe
      :return: The annual reduction


   .. method:: get_regression(self, target: pd.Series)


      Get the regression parameter and intercept from the model's output.

      :param target: The target as a row of a dataframe
      :return: The regression parameter and intercept


   .. method:: _merge_regression(self, data: pd.DataFrame)


      Merge the data with the regression parameters from the SBTi model.

      :param data: The data to merge
      :return: The data set, amended with the regression parameters


   .. method:: get_score(self, target: pd.Series)


      Get the temperature score for a certain target based on the annual reduction rate and the regression parameters.

      :param target: The target as a row of a dataframe
      :return: The temperature score


   .. method:: get_ghc_temperature_score(self, row: pd.Series, company_data: pd.DataFrame)


      Get the aggregated temperature score for a certain company based on the emissions of company.

      :param company_data: The original data, grouped by company, time frame and scope category
      :param row: The row to calculate the temperature score for (if the scope of the row isn't s1s2s3, it will return the original score
      :return: The aggregated temperature score for a company


   .. method:: get_default_score(self, target: pd.Series)


      Get the temperature score for a certain target based on the annual reduction rate and the regression parameters.

      :param target: The target as a row of a dataframe
      :return: The temperature score


   .. method:: _prepare_data(self, data: pd.DataFrame)


      Prepare the data such that it can be used to calculate the temperature score.

      :param data: The original data set as a pandas data frame
      :return: The extended data frame


   .. method:: _calculate_company_score(self, data)


      Calculate the combined s1s2s3 scores for all companies.

      :param data: The original data set as a pandas data frame
      :return: The data frame, with an updated s1s2s3 temperature score


   .. method:: calculate(self, data: pd.DataFrame)


      Calculate the temperature for a dataframe of company data.

      Required columns:

      * target_reference_number: Int *x* of Abs *x*
      * scope: The scope of the target. This should be a valid scope in the SR15 mapping
      * scope_category: The scope category, options: "s1s2", "s3", "s1s2s3"
      * base_year: The base year of the target
      * start_year: The start year of the target
      * target_year: The year when the target should be achieved
      * time_frame: The time frame of the target (short, mid, long) -> This field is calculated by the target valuation protocol.
      * reduction_from_base_year: Targeted reduction in emissions from the base year
      * emissions_in_scope: Company emissions in the target's scope at start of the base year
      * achieved_reduction: The emission reduction that has already been achieved
      * industry: The industry the company is working in. This should be a valid industry in the SR15 mapping. If not it will be converted to "Others" (or whichever value is set in the config as the default).
      * s1s2_emissions: Total company emissions in the S1 + S2 scope
      * s3_emissions: Total company emissions in the S3 scope
      * market_cap: Market capitalization of the company. Only required to use the MOTS portfolio aggregation.
      * investment_value: The investment value of the investment in this company. Only required to use the MOTS, EOTS, ECOTS and AOTS portfolio aggregation.
      * company_enterprise_value: The enterprise value of the company. Only required to use the EOTS portfolio aggregation.
      * company_ev_plus_cash: The enterprise value of the company plus cash. Only required to use the ECOTS portfolio aggregation.
      * company_total_assets: The total assets of the company. Only required to use the AOTS portfolio aggregation.
      * company_revenue: The revenue of the company. Only required to use the ROTS portfolio aggregation.

      :param data: The data set
      :return: A data frame containing all relevant information for the targets and companies


   .. method:: aggregate_scores(self, data: pd.DataFrame, portfolio_aggregation_method: PortfolioAggregationMethod, grouping: Optional[list] = None)


      Aggregate scores to create a portfolio score per time_frame (short, mid, long).

      :param data: The results of the calculate method
      :param portfolio_aggregation_method: PortfolioAggregationMethod: The aggregation method to use
      :param grouping: The grouping to use
      :return: A weighted temperature score for the portfolio


   .. method:: _calculate_company_unique_sum(self, data: pd.DataFrame, col: str)


      Given a data set, calculate a sum which is unique at the company level (such that each field is counted once
      per company).

      :param data: The data set
      :param col: The column name
      :return: The sum of the given column, with each company being counted once


   .. method:: _calculate_scope_weight(self, company_data: pd.DataFrame)


      Calculate the weight that a certain scope has in the attribution calculation (which calculates how much of the total score is dependent on the default score).

      :param company_data: The original data, for a specific company and time frame, indexed by scope category
      :return: A scope weight for all three scopes (s1s2, s3 and s1s2s3). The first two are either 0 (does not use the default score) or 1 (uses the default score). The s1s2s3 is a combination of the other two, weighted by emissions.


   .. method:: temperature_score_influence_percentage(self, data: pd.DataFrame, aggregation_method: PortfolioAggregationMethod)


      Determines which part of the aggregated temperature can be attributed to the default score, instead of to actual
      targets.

      :param data: The output of the temperature score method
      :param aggregation_method: The aggregation method that should be used to calculate the importance of each temperature score
      :return: A dictionary containing for each time-frame and scope, the percentage that can be attributed to the default score.


   .. method:: columns_percentage_distribution(self, data: pd.DataFrame, columns: List[str])


      Percentage distribution of specific column or columns

      :param data: output from the target_validation
      :param columns: specified column names the client would like to have a percentage distribution
      :return: percentage distribution of specified columns


   .. method:: set_scenario(self, scenario: Scenario)


      Set the scenario that should be used to calculate the temperature score.

      :param scenario: The scenario that should be used


   .. method:: cap_scores(self, scores: pd.DataFrame)


      Cap the temperature scores in the input data frame to a certain value, based on the scenario that's being used. 
      This can either be for the whole data set, or only for the top X contributors.

      :param scores: The data set with the temperature scores
      :return: The input data frame, with capped scores


   .. method:: anonymize_data_dump(self, scores: pd.DataFrame)


      Anonymize the scores by deleting the company IDs (ISIC) and renaming the companies.

      :param scores: The data set with the temperature scores
      :return: The input data frame, anonymized


   .. method:: merge_percentage_coverage_to_aggregations(self, aggregations: dict, temperature_percentage_coverage: dict)


      Iterates over two dictionaries and adds keys from second dictionary to the first.

      :param temperature_percentage_coverage: first 'main' dictionary where keys should be added
      :param aggregations: second dictionary where from key-value pairs are added to first dictionary
      :return: The merges aggregations



